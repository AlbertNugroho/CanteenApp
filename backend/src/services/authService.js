const db = require('../config/db');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

/**
 * Register a new user (customer or seller)
 * @param {Object} userData - User registration data
 * @param {string} userType - Type of user ('customer' or 'seller')
 * @returns {Promise<Object>} Registered user data
 */
exports.register = async (userData, userType) => {
  try {
    const { email, password, name } = userData;
    
    if (userType === 'seller') {
      // Check if tenant already exists
      const [existingTenant] = await db.query(
        'SELECT * FROM mstenant WHERE email_tenant = ?',
        [email]
      );
      
      if (existingTenant.length > 0) {
        throw new Error('Tenant already exists with this email');
      }
      
      // Hash password with fewer rounds to generate shorter hash
      const salt = await bcrypt.genSalt(8);
      const hashedPassword = await bcrypt.hash(password, salt);
      
      // Insert new tenant - Note: ID will be generated by trigger
      await db.query(
        'INSERT INTO mstenant (nama_tenant, email_tenant, pw_tenant) VALUES (?, ?, ?)',
        [name, email, hashedPassword]
      );
      
      // Get the newly inserted tenant data
      const [tenant] = await db.query(
        'SELECT id_tenant, nama_tenant, email_tenant FROM mstenant WHERE email_tenant = ?',
        [email]
      );
      
      return {
        ...tenant[0],
        role: 'seller'
      };
    } else {
      // Check if user already exists
      const [existingUser] = await db.query(
        'SELECT * FROM msuser WHERE email_user = ?',
        [email]
      );
      
      if (existingUser.length > 0) {
        throw new Error('User already exists with this email');
      }
      
      // Hash password with fewer rounds to generate shorter hash
      const salt = await bcrypt.genSalt(8);
      const hashedPassword = await bcrypt.hash(password, salt);
      
      // Insert new user - Note: ID will be generated by trigger
      await db.query(
        'INSERT INTO msuser (nama_user, email_user, pw_user) VALUES (?, ?, ?)',
        [name, email, hashedPassword]
      );
      
      // Get the newly inserted user data
      const [users] = await db.query(
        'SELECT id_user, nama_user, email_user FROM msuser WHERE email_user = ? ORDER BY id_user DESC LIMIT 1',
        [email]
      );
      
      if (!users || users.length === 0) {
        throw new Error('Failed to retrieve user after registration');
      }
      
      return {
        ...users[0],
        role: 'customer'
      };
    }
  } catch (error) {
    console.error('Error in register service:', error);
    throw error;
  }
};

/**
 * Login user
 * @param {string} email - User email
 * @param {string} password - User password
 * @returns {Promise<Object>} Login response with token and user data
 */
exports.login = async (email, password) => {
  try {
    // First try to find a tenant
    const [tenants] = await db.query(
      'SELECT * FROM mstenant WHERE email_tenant = ?',
      [email]
    );
    
    if (tenants.length > 0) {
      // User is a tenant/seller
      const tenant = tenants[0];
      
      // Verify password
      const isMatch = await bcrypt.compare(password, tenant.pw_tenant);
      if (!isMatch) {
        throw new Error('Invalid credentials');
      }
      
      // Create JWT token
      const token = jwt.sign(
        { id: tenant.id_tenant, role: 'seller' },
        process.env.JWT_SECRET,
        { expiresIn: '24h' }
      );
      
      // Remove password from tenant object
      delete tenant.pw_tenant;
      
      return {
        token,
        user: {
          ...tenant,
          role: 'seller'
        }
      };
    }
    
    // If not found in tenants, try users
    const [users] = await db.query(
      'SELECT * FROM msuser WHERE email_user = ?',
      [email]
    );
    
    if (users.length === 0) {
      throw new Error('Invalid credentials');
    }
    
    const user = users[0];
    
    // Verify password
    const isMatch = await bcrypt.compare(password, user.pw_user);
    if (!isMatch) {
      throw new Error('Invalid credentials');
    }
    
    // Create JWT token
    const token = jwt.sign(
      { id: user.id_user, role: 'customer' },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    // Remove password from user object
    delete user.pw_user;
    
    return {
      token,
      user: {
        ...user,
        role: 'customer'
      }
    };
  } catch (error) {
    console.error('Error in login service:', error);
    throw error;
  }
}; 